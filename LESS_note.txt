【less】

.rounded-corners (@radius: 5px) {
    -webkit-border-radius: @radius;
    -moz-border-radius: @radius;
    -ms-border-radius: @radius;
    -o-border-radius: @radius;
    border-radius: @radius;
}

#header {
    .rounded-corners;
}
#footer {
    .rounded-corners(10px);
}




---------------------------

？ desaturate 是不是 API 提供的计算方法？
-- 好像是的；

#footer {
    color: (@base-color + #003300);
    border-color: desaturate(@red, 10%);
}







---------------------------

@fnord: "I am fnord.";
@var: 'fnord';
content: @@var;


解析后：
content: "I am fnord.";








---------------------------

如果对同一个变量定义两次的话，在当前作用域中最后一次定义的将被使用。
-- 注意：作用域；

@var: 0;
.class1 {
    @var: 1;
    .class {
        @var: 2;
        three: @var;
        @var: 3;
    }
    one: @var;
}

会编译成：
.class1 .class {
    three: 3;
}
.class1 {
    one: 1;
}





---------------------------

.lazy-eval-scope {
    width: @var;
    @a: 9%;
}

@var: @a;
@a: 100%;

编译成：
.lazy-eval-scope {
    width: 9%;     // ？？ 100% 吧？
}

-- 真有可能是 9%，因为后面定义的 @a 已经超出作用域了。 




---------------------------

属性集

.bordered {
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}

那如果我们现在需要在其他 class 中引入那些通用的属性集，那么我们只需要在任何 class 中像下面这样调用就可以了：

#menu a {
    color: #111;
    .bordered;
}




---------------------------

？ 带参数混合和不带参数混合好像没啥区别？

.wrap () {
    text-wrap: wrap;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    word-wrap: break-word;
}

pre { .wrap }

输出：

pre {
    text-wrap: wrap;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    word-wrap: break-word;
}






---------------------------

.mixin(@color) {
    color-1: @color;
}
.mixin(@color; @padding:2) {
    color-2: @color;
    padding-2: @padding;
}
.mixin(@color; @padding; @margin: 2) {
    color-3: @color;
    padding-3: @padding;
    margin: @margin @margin @margin @margin;
}
.some .selector div {
    .mixin(#008000);
}

编译结果：

.some .selector div {
    color-1: #008000;
    color-2: #008000;    // ？？
    padding-2: 2;        // ？？ 
}

？ 为什么两个参数的方法也会被调用？





---------------------------

.mixin (...) {        // 接受 0-N 个参数
.mixin () {           // 不接受任何参数
.mixin (@a: 1) {      // 接受 0-1 个参数
.mixin (@a: 1, ...) { // 接受 0-N 个参数
.mixin (@a, ...) {    // 接受 1-N 个参数

？ “:”传进来的参数不是参数，只是定义？
？ ":" 应该是可选的意思？

-- "," 传的参数才算参数？

？ "," 和 ";" 传的参有什么区别？
-- 没有分组用 ","  有分组用 ";"
-- 逗号有两重含义：它既可以表示混合的参数，也可以表示一个参数中一组值的分隔符。










---------------------------

？？ 

.mixin (@a, @rest...) {
    // @rest 表示 @a 之后的参数
    // @arguments 表示所有参数
}








---------------------------

.mixin (dark, @color) {
    color: darken(@color, 10%);
}
.mixin (light, @color) {
    color: lighten(@color, 10%);
}
.mixin (@_, @color) {
    display: block;
}

然后调用：

@switch: light;

.class {
    .mixin(@switch, #888);
}

？ @switch 是 API 中提供的方法？？






---------------------------

？ lightness(@a) 在哪里定义了？

.mixin (@a) when (lightness(@a) >= 50%) {
    background-color: black;
}
.mixin (@a) when (lightness(@a) < 50%) {
    background-color: white;
}
.mixin (@a) {
    color: @a;
}

要点在于关键词 when，它引入了一个 guard 条件 （这里只用到一个 guard）。现在如果运行下面的代码：

.class1 { .mixin(#ddd) }
.class2 { .mixin(#555) }

将会得到以下输出结果：

.class1 {
    background-color: black;
    color: #ddd;
}
.class2 {
    background-color: white;
    color: #555;
}





---------------------------

.mixin (@a, @b: 0) when (isnumber(@b)) { ... }
.mixin (@a, @b: black) when (iscolor(@b)) { ... }

.mixin (@a) when (isnumber(@a)) and (@a > 0) { ... }
.mixin (@b) when not (@b > 0) { ... 








---------------------------

&:hover

#header { color: black;
    .navigation { font-size: 12px }
    .logo { width: 300px;
        &:hover { text-decoration: none }
    }
}







---------------------------

？？ 未看

.child, .sibling {
    .parent & {
        color: black;
    }
    & + & {
        color: red;
    }
}

输出：

.parent .child,
.parent .sibling {
    color: black;
}
.child + .child,
.child + .sibling,
.sibling + .child,
.sibling + .sibling {
    color: red;
}






---------------------------

@import 有变量提升的效果；









---------------------------

？？ 

例如有被导入的文件library.less：

@imported-color: red;
h1 { color: green; }

主样式文件导入了上面的library.less：

@import "library.less" screen and (max-width: 400px); // 通过media query指定的import
@import "library.less"; // 无media query的import

.class {
    color: @importedColor; // 使用导入的变量
}

将会编译出：

// 对应通过media query指定的import
@media screen and (max-width: 400px) {
    h1 { color: green; }
}

// 对应无media query的import
h1 { color: green; }
.class {
    // 使用导入的变量
    color: #ff0000;
}








---------------------------

字符串插值： @{name} 
-- 也用于：选择器插值

@name: blocked;
.@{name} {
    color: black;
}


？ 和普通变量有什么区别？是不是只是用在字符串中？？










---------------------------

避免编译

.class {
    filter: ~"ms:alwaysHasItsOwnSyntax.For.Stuff()";
}

输出结果为：

.class {
    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();
}

在避免编译的值中间也可以像字符串一样插入变量：

.class {
    @what: "Stuff";
    filter: ~"ms:alwaysHasItsOwnSyntax.For.@{what}()";
}






















