* table.js

-- 跑一下 table.js; 另外看看能不能做一个列排序功能；

$table = $('#listTable').table({
	queryDefine : QueryDefine,
	rowClickFn : null,// 行单击事件
	rowDblClickFn : function(selRow){goToDetailPage(LinkPagUid.detail,selRow);},// 行双击事件
	pageSize : 15,
	rowSelectMode : ListPagTyp == 'QRY' ? 'Single' : 'Multi',
	rowCheckbox : true		
});	


$table.table('fillTable', 1);

-- 得到 obj，但是怎么把 obj 传给 fillTable？？

！ $('xx').table({obj}) 没有显示 table？？只有 filltable 才会显示 table？？
-- 确实，初始化 branch:init() -> genSearchPrdLv1() -> $table.table('fillTable', 1);





-------------------------

* proxy()
-- 好像没啥特别的；就是在当前对象里面执行另外对象的方法而已；

if (typeof options === 'string') {
	if (!_this) {
		window.console.error('Not initialized, can not call method : ' + options);
	} else if (!$.isFunction(_this[options]) || options.charAt(0) === '_') {
		window.console.error('No such method : ' + options);
	} else {
		if (!(args instanceof Array)) {
			args = [ args ];
		}
		result = _this[options].apply(_this, args);
	}
}


var Table = function (element, options) {
	...
	return {
		options: this.options,
		exportToExcel: $.proxy(this.exportToExcel, this),
		fillTable: $.proxy(this.fillTable, this),
		...
	};


* var rows = $table.table('getSelectRow');
-- $table.table() 好像就是 return 出来的一堆方法组成的对象；


？ _this[options].apply(_this, args); 其实可以写成 _this[options]; ？？
？ 之所以要 apply()，是为了要额外传入一个参数组？？





** 语法1
$(selector).proxy(function,context)

test=function()
{
	this.txt="这是一个对象属性";
	$("div").click($.proxy(this.myClick,this));
};

test.prototype.myClick = function(event)
{
	alert(this.txt);
	alert(event.currentTarget.nodeName);
};

var x = new test();






** 语法2：
$(selector).proxy(context,name)

  var objPerson = {
    name: "John Doe",
    age: 32,
    test: function(){
      $("p").after("Name: " + this.name + "<br> Age: " + this.age);
    }
  };
  $("button").click($.proxy(objPerson,"test"));


