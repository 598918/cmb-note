* 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
-- 类似 js 方法内变量； 

* 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 
？ 额，跟类变量有什么不一样？？

* 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 
-- 感觉类似 js 的全局变量；





* 构造方法
-- 在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

public class Puppy{
   public Puppy(){
   }

   public Puppy(String name){
      // 这个构造器仅有一个参数：name
   }
}






-----------------------------

创建对象

public class Puppy{
   public Puppy(String name){
      //这个构造器仅有一个参数：name
      System.out.println("Passed Name is :" + name ); 
   }
   public static void main(String []args){
      // 下面的语句将创建一个Puppy对象
      Puppy myPuppy = new Puppy( "tommy" );
   }
}

Passed Name is :tommy

-- 感觉有点像 jquery 插件；





-----------------------------

实例

-- main 跟 $(function(){}) 很像，都是一个类似舞台的东西；
-- 不同的是，设置方法的时候，js 是 xx.prototype.func；而 java 是直接 func，因为整个 class 都是一个 xx 对象，所有的方法都默认添加到 xx 下。



public class Puppy{
   int puppyAge;
   public Puppy(String name){
      // 这个构造器仅有一个参数：name
      System.out.println("Passed Name is :" + name ); 
   }

   public void setAge( int age ){
       puppyAge = age;
   }

   public int getAge( ){
       System.out.println("Puppy's age is :" + puppyAge ); 
       return puppyAge;
   }

   public static void main(String []args){
      /* 创建对象 */
      Puppy myPuppy = new Puppy( "tommy" );
      /* 通过方法来设定age */
      myPuppy.setAge( 2 );
      /* 调用另一个方法获取age */
      myPuppy.getAge( );
      /*你也可以像下面这样访问成员变量 */
      System.out.println("Variable Value :" + myPuppy.puppyAge ); 
   }
}





-----------------------------

import java.io.*;

-- 一个源文件中只能有一个public类，可以有多个非public类 

-- 如果一个类定义在某个包中，那么package语句应该在源文件的首行。 
-- 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。

package com.cmb.bus.buswap.base;

import java.sql.Date;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.frm.base.exception.FrameworkException;
import com.frm.base.model.ICacheTableR;
import com.frm.base.util.StringUtil;
import com.frm.container.loader.ContainerFactory;



？import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 ？？

？类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。这些将在访问控制章节介绍。

？除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。





-----------------------------

* 局部变量

？ 局部变量是在栈上分配的。
-- 如果是个对象呢？


* 局部变量没有默认值，所以局部变量量被声明后，必须经过初始化，才可以使用。
 
-- 下面这样写是错的：
int age;


-----------------------------

实例变量

-- 实例变量可以不初始化？

？ public 和 private 怎么区分？？

-- private：在同一类内可见。
-- public：对所有类可见。

？ 这里的类怎么体现？？
-- 比如 Employee 和 class extends Employee 这样算同一类？


？protected 修饰符指定，对同一包内的类和所有子类可见。



public class Employee{
   // 这个成员变量对子类可见
   public String name;
   // 私有变量，仅在该类可见
   private double salary;
   //在构造器中对name赋值
   public Employee (String empName){
      name = empName;
   }






-----------------------------

类变量（静态变量）

？ 除了 static 外，还有什么不同的地方吗？？








-----------------------------

* private 有点像 js 的闭包啊。

public class Logger {
   private String format;
   public String getFormat() {
      return this.format;
   }
   public void setFormat(String format) {
      this.format = format;
   }
}

-- Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值。
-- 为了使其他类能够操作该变量，定义了两个public方法：getFormat() （返回format的值）和setFormat(String)（设置format的值） 






-----------------------------

？？ 被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。 
-- 这种描述跟 public 有什么不同？？



？ Protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected。 
？？　类和接口？？



？ 子类能访问 Protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。 
？ 怎么办到？







class AudioPlayer {
   protected boolean openSpeaker(Speaker sp) {
      // 实现细节
   }
}

class StreamingAudioPlayer {
   boolean openSpeaker(Speaker sp) {
      // 实现细节
   }
}

-- 好像和 public 没什么不同？

-- 如果把openSpeaker()方法声明为private，那么除了AudioPlayer之外的类将不能访问该方法。
-- 如果把openSpeaker()声明为public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为protected。 






-----------------------------

访问控制和继承

请注意以下方法继承的规则： 
-- 父类中声明为public的方法在子类中也必须为public。
-- 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。
-- 父类中默认修饰符声明的方法，能够在子类中声明为private。
-- 父类中声明为private的方法，不能够被继承。





静态方法不能使用类的非静态变量

private static int numInstances = 0;
protected static int getCount() {
	return numInstances;
}






-----------------------------

？ 被声明为final的对象的引用不能指向不同的对象。
？ 但是final对象里的数据可以被改变。也就是说final对象的引用不能改变，但是里面的值可以改变。


public class Test{
  final int value = 10;
  // 下面是声明常量的实例
  public static final int BOXWIDTH = 6;
  static final String TITLE = "Manager";

  public void changeValue(){
     value = 12; //将输出一个错误      // ？？ 为什么会输出错误，不是说 final 的只可以改吗？
  }
}






-----------------------------

抽象方法

-- 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成final和strict。 
-- 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 
-- 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 
-- 抽象方法的声明以分号结尾，例如：public abstract sample(); 

实例：

public abstract class SuperClass{
    abstract void m(); //抽象方法
}
 
class SubClass extends SuperClass{
     //实现抽象方法
      void m(){
          .........
      }
}






-----------------------------

？ 有点不太懂；

Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。
而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。
这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。 

实例：

public class MyRunnable implements Runnable
{
    private volatile boolean active;
    public void run()
    {
        active = true;
        while (active) // line 1
        {
            // 代码
        }
    }
    public void stop()
    {
        active = false; // line 2
    }
}

一般地，在一个线程中调用run()方法，在另一个线程中调用stop()方法。
如果line 1中的active位于缓冲区的值被使用，那么当把line 2中的active设置成false时，循环也不会停止。 
























